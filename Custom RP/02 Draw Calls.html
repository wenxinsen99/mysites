<!DOCTYPE html>
<html lang="cn">
	<head prefix>
		<meta charset="utf-8" />
		<title>随心记</title>
		<meta name="viewport" content="width=device-width" />
        <link rel="stylesheet" href="../styles.css">
		<link rel="icon" href="../favicon.jpg" sizes="16x16">
	</head>

	<body>
		<header>
			<nav>
				<a href="../index.html"><img src="../favicon.jpg" alt="favicon" width="45" height="45"></a>
			</nav>
			<nav>
				<a href="../index.html">Home</a>
			</nav>
		</header>
		
		<main>
			<article>
                <header>
				    <h1>Draw Calls</h1>
                </header>

                <section>
					<h3>SRP Batcher</h3>

                    <p>
                        批处理(Batching)是将多个 draw call 合并的过程，减少 CPU 和 GPU 之间的通信时间。
                    </p>
                    <p>
                        Unity 的 SRP Batcher 允许在不使用 GPU 实例化(Instancing) 的情况下批处理 draw call。SRP Batcher 通过将多个材质相同的物体合并为一个 draw call 来减少 draw call 的数量。
                    </p>
				</section>

                <section>
                    <h3>GPU Instancing</h3>
                    <p>
                        GPU 实例化(Instancing)是另一种将多个使用相同的网格(mesh)物体合并为一个 draw call 的过程。
                    </p>
                </section>

                <section>
                    <h3>Dynamic Batching</h3>
                    <p>
                        另一种减少 draw call 的方法，是一种老的技术用于将较小的 mesh 的物体并且共享一个 material 合并成一个大的 mesh 进行绘制。比如 Cube 可以但 Sphere 不可以。
                        需要禁用 GPU Instancing 才能启用，也需要禁用 SRP Batcher。
                    </p>
                    <p>
                        In general GPU instancing works better than dynamic batching. The approach also has some caveats, for example when different scales are involved then the normal vectors of the larger mesh aren't guaranteed to be unit-length. Also, draw order changes as it's now a single mesh instead of multiple.
                    </p>
                </section>
			</article>
		</main>

		<footer>
			<h3>呱</h3>
		</footer>

		<script src="../main.js"></script>
	</body>
</html>